<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/oliver-moran/jimp#readme"

    >jimp (v0.2.27)</a>
</h1>
<h4>An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jimp">module jimp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.phash">
            function <span class="apidocSignatureSpan">jimp.</span>phash
            <span class="apidocSignatureSpan">(size, smallerSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize">
            function <span class="apidocSignatureSpan">jimp.</span>resize
            <span class="apidocSignatureSpan">(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jimp.</span>phash.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jimp.</span>resize.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jimp.</span>resize2</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jimp.phash">module jimp.phash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.phash.phash">
            function <span class="apidocSignatureSpan">jimp.</span>phash
            <span class="apidocSignatureSpan">(size, smallerSize)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jimp.phash.prototype">module jimp.phash.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.phash.prototype.distance">
            function <span class="apidocSignatureSpan">jimp.phash.prototype.</span>distance
            <span class="apidocSignatureSpan">(s1, s2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.phash.prototype.getHash">
            function <span class="apidocSignatureSpan">jimp.phash.prototype.</span>getHash
            <span class="apidocSignatureSpan">(img)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jimp.phash.prototype.</span>size</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jimp.phash.prototype.</span>smallerSize</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jimp.resize">module jimp.resize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.resize">
            function <span class="apidocSignatureSpan">jimp.</span>resize
            <span class="apidocSignatureSpan">(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jimp.resize.prototype">module jimp.resize.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.bypassResizer">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>bypassResizer
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.configurePasses">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>configurePasses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.generateFloatBuffer">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>generateFloatBuffer
            <span class="apidocSignatureSpan">(bufferLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.generateUint8Buffer">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>generateUint8Buffer
            <span class="apidocSignatureSpan">(bufferLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.initialize">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>initialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.initializeFirstPassBuffers">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>initializeFirstPassBuffers
            <span class="apidocSignatureSpan">(BILINEARAlgo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.initializeSecondPassBuffers">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>initializeSecondPassBuffers
            <span class="apidocSignatureSpan">(BILINEARAlgo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resize">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resize
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resizeHeightInterpolated">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeHeightInterpolated
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resizeHeightRGB">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeHeightRGB
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resizeHeightRGBA">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeHeightRGBA
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resizeWidthInterpolatedRGB">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthInterpolatedRGB
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resizeWidthInterpolatedRGBA">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthInterpolatedRGBA
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resizeWidthRGB">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthRGB
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize.prototype.resizeWidthRGBA">
            function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthRGBA
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jimp.resize2">module jimp.resize2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize2._interpolate2D">
            function <span class="apidocSignatureSpan">jimp.resize2.</span>_interpolate2D
            <span class="apidocSignatureSpan">(src, dst, options, interpolate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize2.bezierInterpolation">
            function <span class="apidocSignatureSpan">jimp.resize2.</span>bezierInterpolation
            <span class="apidocSignatureSpan">(src, dst, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize2.bicubicInterpolation">
            function <span class="apidocSignatureSpan">jimp.resize2.</span>bicubicInterpolation
            <span class="apidocSignatureSpan">(src, dst, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize2.bilinearInterpolation">
            function <span class="apidocSignatureSpan">jimp.resize2.</span>bilinearInterpolation
            <span class="apidocSignatureSpan">(src, dst, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize2.hermiteInterpolation">
            function <span class="apidocSignatureSpan">jimp.resize2.</span>hermiteInterpolation
            <span class="apidocSignatureSpan">(src, dst, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jimp.resize2.nearestNeighbor">
            function <span class="apidocSignatureSpan">jimp.resize2.</span>nearestNeighbor
            <span class="apidocSignatureSpan">(src, dst, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jimp" id="apidoc.module.jimp">module jimp</a></h1>


    <h2>
        <a href="#apidoc.element.jimp.phash" id="apidoc.element.jimp.phash">
        function <span class="apidocSignatureSpan">jimp.</span>phash
        <span class="apidocSignatureSpan">(size, smallerSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImagePHash(size, smallerSize) {
    this.size = this.size || size;
    this.smallerSize = this.smallerSize || smallerSize;
    initCoefficients(this.size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize" id="apidoc.element.jimp.resize">
        function <span class="apidocSignatureSpan">jimp.</span>resize
        <span class="apidocSignatureSpan">(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
    this.widthOriginal = Math.abs(parseInt(widthOriginal) || 0);
    this.heightOriginal = Math.abs(parseInt(heightOriginal) || 0);
    this.targetWidth = Math.abs(parseInt(targetWidth) || 0);
    this.targetHeight = Math.abs(parseInt(targetHeight) || 0);
    this.colorChannels = (!!blendAlpha) ? 4 : 3;
    this.interpolationPass = !!interpolationPass;
    this.resizeCallback = (typeof resizeCallback == &#x22;function&#x22;) ? resizeCallback : function (returnedArray) {};
    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
    this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
    this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
    this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
    this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
    this.initialize();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Jimp.diff = function (img1, img2, threshold) {
if (&#x22;object&#x22; != typeof img1 || img1.constructor != Jimp || &#x22;object&#x22; != typeof img2 || img2.constructor != Jimp
)
    return throwError.call(this, &#x22;img1 and img2 must be an Jimp images&#x22;);

if (img1.bitmap.width != img2.bitmap.width || img1.bitmap.height != img2.bitmap.height) {
    switch (img1.bitmap.width * img1.bitmap.height &#x3e; img2.bitmap.width * img2.bitmap.height) {
        case true: // img1 is bigger
            img1 = img1.clone().<span class="apidocCodeKeywordSpan">resize</span>(img2.bitmap.width, img2.bitmap.height);
            break;
        default:
            // img2 is bigger (or they are the same in area)
            img2 = img2.clone().resize(img1.bitmap.width, img1.bitmap.height);
            break;
    }
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jimp.phash" id="apidoc.module.jimp.phash">module jimp.phash</a></h1>


    <h2>
        <a href="#apidoc.element.jimp.phash.phash" id="apidoc.element.jimp.phash.phash">
        function <span class="apidocSignatureSpan">jimp.</span>phash
        <span class="apidocSignatureSpan">(size, smallerSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImagePHash(size, smallerSize) {
    this.size = this.size || size;
    this.smallerSize = this.smallerSize || smallerSize;
    initCoefficients(this.size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jimp.phash.prototype" id="apidoc.module.jimp.phash.prototype">module jimp.phash.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jimp.phash.prototype.distance" id="apidoc.element.jimp.phash.prototype.distance">
        function <span class="apidocSignatureSpan">jimp.phash.prototype.</span>distance
        <span class="apidocSignatureSpan">(s1, s2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distance = function (s1, s2) {
    var counter = 0;
    for (var k = 0; k &#x3c; s1.length; k++) {
        if (s1[k] != s2[k]) {
            counter++;
        }
    }
    return (counter / s1.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param img2 a Jimp image to compare
 * @returns a number ranging from 0 to 1, 0 means they are believed to be identical
 */
Jimp.distance = function (img1, img2) {
    var phash = new ImagePHash();
    var hash1 = phash.getHash(img1);
    var hash2 = phash.getHash(img2);
    return phash.<span class="apidocCodeKeywordSpan">distance</span>(hash1, hash2);
}


// An object representing a bitmap in memory, comprising:
//  - data: a buffer of the bitmap data
//  - width: the width of the image in pixels
//  - height: the height of the image in pixels
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.phash.prototype.getHash" id="apidoc.element.jimp.phash.prototype.getHash">
        function <span class="apidocSignatureSpan">jimp.phash.prototype.</span>getHash
        <span class="apidocSignatureSpan">(img)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHash = function (img) {
<span class="apidocCodeCommentSpan">    /* 1. Reduce size.
     * Like Average Hash, pHash starts with a small image.
     * However, the image is larger than 8x8; 32x32 is a good size.
     * This is really done to simplify the DCT computation and not
     * because it is needed to reduce the high frequencies.
     */
</span>    img = img.clone().resize(this.size, this.size);

    /* 2. Reduce color.
     * The image is reduced to a grayscale just to further simplify
     * the number of computations.
     */
    img.grayscale();

    var vals = [];

    for (var x = 0; x &#x3c; img.bitmap.width; x++) {
        vals[x] = [];
        for (var y = 0; y &#x3c; img.bitmap.height; y++) {
            vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
        }
    }

    /* 3. Compute the DCT.
     * The DCT separates the image into a collection of frequencies
     * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses
     * a 32x32 DCT.
     */
    var dctVals = applyDCT(vals, this.size);

    /* 4. Reduce the DCT.
     * This is the magic step. While the DCT is 32x32, just keep the
     * top-left 8x8. Those represent the lowest frequencies in the
     * picture.
     */
    /* 5. Compute the average value.
     * Like the Average Hash, compute the mean DCT value (using only
     * the 8x8 DCT low-frequency values and excluding the first term
     * since the DC coefficient can be significantly different from
     * the other values and will throw off the average).
     */
    var total = 0;

    for (var x = 0; x &#x3c; this.smallerSize; x++) {
        for (var y = 0; y &#x3c; this.smallerSize; y++) {
            total += dctVals[x][y];
        }
    }

    var avg = total / (this.smallerSize * this.smallerSize);

    /* 6. Further reduce the DCT.
     * This is the magic step. Set the 64 hash bits to 0 or 1
     * depending on whether each of the 64 DCT values is above or
     * below the average value. The result doesn&#x27;t tell us the
     * actual low frequencies; it just tells us the very-rough
     * relative scale of the frequencies to the mean. The result
     * will not vary as long as the overall structure of the image
     * remains the same; this can survive gamma and color histogram
     * adjustments without a problem.
     */
    var hash = &#x22;&#x22;;

	var count = 0;
    for (var x = 0; x &#x3c; this.smallerSize; x++) {
        for (var y = 0; y &#x3c; this.smallerSize; y++) {
            hash += (dctVals[x][y] &#x3e; avg?&#x22;1&#x22;:&#x22;0&#x22;);
        }
    }

    return hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Calculates the hamming distance of two images based on their perceptual hash
 * @param img1 a Jimp image to compare
 * @param img2 a Jimp image to compare
 * @returns a number ranging from 0 to 1, 0 means they are believed to be identical
 */
Jimp.distance = function (img1, img2) {
    var phash = new ImagePHash();
    var hash1 = phash.<span class="apidocCodeKeywordSpan">getHash</span>(img1);
    var hash2 = phash.getHash(img2);
    return phash.distance(hash1, hash2);
}


// An object representing a bitmap in memory, comprising:
//  - data: a buffer of the bitmap data
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jimp.resize" id="apidoc.module.jimp.resize">module jimp.resize</a></h1>


    <h2>
        <a href="#apidoc.element.jimp.resize.resize" id="apidoc.element.jimp.resize.resize">
        function <span class="apidocSignatureSpan">jimp.</span>resize
        <span class="apidocSignatureSpan">(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
    this.widthOriginal = Math.abs(parseInt(widthOriginal) || 0);
    this.heightOriginal = Math.abs(parseInt(heightOriginal) || 0);
    this.targetWidth = Math.abs(parseInt(targetWidth) || 0);
    this.targetHeight = Math.abs(parseInt(targetHeight) || 0);
    this.colorChannels = (!!blendAlpha) ? 4 : 3;
    this.interpolationPass = !!interpolationPass;
    this.resizeCallback = (typeof resizeCallback == &#x22;function&#x22;) ? resizeCallback : function (returnedArray) {};
    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
    this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
    this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
    this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
    this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
    this.initialize();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Jimp.diff = function (img1, img2, threshold) {
if (&#x22;object&#x22; != typeof img1 || img1.constructor != Jimp || &#x22;object&#x22; != typeof img2 || img2.constructor != Jimp
)
    return throwError.call(this, &#x22;img1 and img2 must be an Jimp images&#x22;);

if (img1.bitmap.width != img2.bitmap.width || img1.bitmap.height != img2.bitmap.height) {
    switch (img1.bitmap.width * img1.bitmap.height &#x3e; img2.bitmap.width * img2.bitmap.height) {
        case true: // img1 is bigger
            img1 = img1.clone().<span class="apidocCodeKeywordSpan">resize</span>(img2.bitmap.width, img2.bitmap.height);
            break;
        default:
            // img2 is bigger (or they are the same in area)
            img2 = img2.clone().resize(img1.bitmap.width, img1.bitmap.height);
            break;
    }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jimp.resize.prototype" id="apidoc.module.jimp.resize.prototype">module jimp.resize.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.bypassResizer" id="apidoc.element.jimp.resize.prototype.bypassResizer">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>bypassResizer
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bypassResizer = function (buffer) {
    //Just return the buffer passsed:
    return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.configurePasses" id="apidoc.element.jimp.resize.prototype.configurePasses">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>configurePasses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configurePasses = function () {
    if (this.widthOriginal == this.targetWidth) {
        //Bypass the width resizer pass:
        this.resizeWidth = this.bypassResizer;
    } else {
        //Setup the width resizer pass:
        this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
        if (this.ratioWeightWidthPass &#x3c; 1 &#x26;&#x26; this.interpolationPass) {
            this.initializeFirstPassBuffers(true);
            this.resizeWidth = (this.colorChannels == 4) ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
        } else {
            this.initializeFirstPassBuffers(false);
            this.resizeWidth = (this.colorChannels == 4) ? this.resizeWidthRGBA : this.resizeWidthRGB;
        }
    }
    if (this.heightOriginal == this.targetHeight) {
        //Bypass the height resizer pass:
        this.resizeHeight = this.bypassResizer;
    } else {
        //Setup the height resizer pass:
        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
        if (this.ratioWeightHeightPass &#x3c; 1 &#x26;&#x26; this.interpolationPass) {
            this.initializeSecondPassBuffers(true);
            this.resizeHeight = this.resizeHeightInterpolated;
        } else {
            this.initializeSecondPassBuffers(false);
            this.resizeHeight = (this.colorChannels == 4) ? this.resizeHeightRGBA : this.resizeHeightRGB;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
this.initialize();
}

Resize.prototype.initialize = function () {
//Perform some checks:
if (this.widthOriginal &#x3e; 0 &#x26;&#x26; this.heightOriginal &#x3e; 0 &#x26;&#x26; this.targetWidth &#x3e; 0 &#x26;&#x26; this
.targetHeight &#x3e; 0) {
    this.<span class="apidocCodeKeywordSpan">configurePasses</span>();
} else {
    throw (new Error(&#x22;Invalid settings specified for the resizer.&#x22;));
}
}

Resize.prototype.configurePasses = function () {
if (this.widthOriginal == this.targetWidth) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.generateFloatBuffer" id="apidoc.element.jimp.resize.prototype.generateFloatBuffer">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>generateFloatBuffer
        <span class="apidocSignatureSpan">(bufferLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateFloatBuffer = function (bufferLength) {
    //Generate a float32 typed array buffer:
    try {
        return new Float32Array(bufferLength);
    } catch (error) {
        return [];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Resize.prototype.bypassResizer = function (buffer) {
//Just return the buffer passsed:
return buffer;
}

Resize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {
//Initialize the internal width pass buffers:
this.widthBuffer = this.<span class="apidocCodeKeywordSpan">generateFloatBuffer</span>(this.widthPassResultSize);
if (!BILINEARAlgo) {
    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
}
}

Resize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {
//Initialize the internal height pass buffers:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.generateUint8Buffer" id="apidoc.element.jimp.resize.prototype.generateUint8Buffer">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>generateUint8Buffer
        <span class="apidocSignatureSpan">(bufferLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateUint8Buffer = function (bufferLength) {
    //Generate a uint8 typed array buffer:
    try {
        return new Uint8Array(bufferLength);
    } catch (error) {
        return [];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!BILINEARAlgo) {
    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
}
}

Resize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {
//Initialize the internal height pass buffers:
this.heightBuffer = this.<span class="apidocCodeKeywordSpan">generateUint8Buffer</span>(this.finalResultSize);
if (!BILINEARAlgo) {
    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
}
}

Resize.prototype.generateFloatBuffer = function (bufferLength) {
//Generate a float32 typed array buffer:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.initialize" id="apidoc.element.jimp.resize.prototype.initialize">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>initialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function () {
    //Perform some checks:
    if (this.widthOriginal &#x3e; 0 &#x26;&#x26; this.heightOriginal &#x3e; 0 &#x26;&#x26; this.targetWidth &#x3e; 0 &#x26;&#x26; this.targetHeight &#x3e; 0) {
        this.configurePasses();
    } else {
        throw (new Error(&#x22;Invalid settings specified for the resizer.&#x22;));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.interpolationPass = !!interpolationPass;
this.resizeCallback = (typeof resizeCallback == &#x22;function&#x22;) ? resizeCallback : function (returnedArray) {};
this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
this.<span class="apidocCodeKeywordSpan">initialize</span>();
}

Resize.prototype.initialize = function () {
//Perform some checks:
if (this.widthOriginal &#x3e; 0 &#x26;&#x26; this.heightOriginal &#x3e; 0 &#x26;&#x26; this.targetWidth &#x3e; 0 &#x26;&#x26; this
.targetHeight &#x3e; 0) {
    this.configurePasses();
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.initializeFirstPassBuffers" id="apidoc.element.jimp.resize.prototype.initializeFirstPassBuffers">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>initializeFirstPassBuffers
        <span class="apidocSignatureSpan">(BILINEARAlgo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeFirstPassBuffers = function (BILINEARAlgo) {
    //Initialize the internal width pass buffers:
    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
    if (!BILINEARAlgo) {
        this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.widthOriginal == this.targetWidth) {
    //Bypass the width resizer pass:
    this.resizeWidth = this.bypassResizer;
} else {
    //Setup the width resizer pass:
    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
    if (this.ratioWeightWidthPass &#x3c; 1 &#x26;&#x26; this.interpolationPass) {
        this.<span class="apidocCodeKeywordSpan">initializeFirstPassBuffers</span>(true);
        this.resizeWidth = (this.colorChannels == 4) ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
    } else {
        this.initializeFirstPassBuffers(false);
        this.resizeWidth = (this.colorChannels == 4) ? this.resizeWidthRGBA : this.resizeWidthRGB;
    }
}
if (this.heightOriginal == this.targetHeight) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.initializeSecondPassBuffers" id="apidoc.element.jimp.resize.prototype.initializeSecondPassBuffers">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>initializeSecondPassBuffers
        <span class="apidocSignatureSpan">(BILINEARAlgo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeSecondPassBuffers = function (BILINEARAlgo) {
    //Initialize the internal height pass buffers:
    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
    if (!BILINEARAlgo) {
        this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.heightOriginal == this.targetHeight) {
        //Bypass the height resizer pass:
        this.resizeHeight = this.bypassResizer;
    } else {
        //Setup the height resizer pass:
        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
        if (this.ratioWeightHeightPass &#x3c; 1 &#x26;&#x26; this.interpolationPass) {
            this.<span class="apidocCodeKeywordSpan">initializeSecondPassBuffers</span>(true);
            this.resizeHeight = this.resizeHeightInterpolated;
        } else {
            this.initializeSecondPassBuffers(false);
            this.resizeHeight = (this.colorChannels == 4) ? this.resizeHeightRGBA : this.resizeHeightRGB;
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resize" id="apidoc.element.jimp.resize.prototype.resize">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resize
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (buffer) {
    this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Jimp.diff = function (img1, img2, threshold) {
if (&#x22;object&#x22; != typeof img1 || img1.constructor != Jimp || &#x22;object&#x22; != typeof img2 || img2.constructor != Jimp
)
    return throwError.call(this, &#x22;img1 and img2 must be an Jimp images&#x22;);

if (img1.bitmap.width != img2.bitmap.width || img1.bitmap.height != img2.bitmap.height) {
    switch (img1.bitmap.width * img1.bitmap.height &#x3e; img2.bitmap.width * img2.bitmap.height) {
        case true: // img1 is bigger
            img1 = img1.clone().<span class="apidocCodeKeywordSpan">resize</span>(img2.bitmap.width, img2.bitmap.height);
            break;
        default:
            // img2 is bigger (or they are the same in area)
            img2 = img2.clone().resize(img1.bitmap.width, img1.bitmap.height);
            break;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resizeHeightInterpolated" id="apidoc.element.jimp.resize.prototype.resizeHeightInterpolated">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeHeightInterpolated
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resizeHeightInterpolated = function (buffer) {
    var ratioWeight = this.ratioWeightHeightPass;
    var weight = 0;
    var finalOffset = 0;
    var pixelOffset = 0;
    var pixelOffsetAccumulated = 0;
    var pixelOffsetAccumulated2 = 0;
    var firstWeight = 0;
    var secondWeight = 0;
    var outputBuffer = this.heightBuffer;
    //Handle for only one interpolation input being valid for start calculation:
    for (; weight &#x3c; 1 / 3; weight += ratioWeight) {
        for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
        }
    }
    //Adjust for overshoot of the last pass&#x27;s counter:
    weight -= 1 / 3;
    for (var interpolationHeightSourceReadStop = this.heightOriginal - 1; weight &#x3c; interpolationHeightSourceReadStop; weight +=
ratioWeight) {
        //Calculate weightings:
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        //Interpolate:
        pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
        pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
        for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels; ++pixelOffset) {
            outputBuffer[finalOffset++] = Math.round((buffer[pixelOffsetAccumulated++] * firstWeight) + (buffer[pixelOffsetAccumulated2
++] * secondWeight));
        }
    }
    //Handle for only one interpolation input being valid for end calculation:
    while (finalOffset &#x3c; this.finalResultSize) {
        for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels;
pixelOffset &#x3c; this.targetWidthMultipliedByChannels; ++pixelOffset) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
        }
    }
    return outputBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resizeHeightRGB" id="apidoc.element.jimp.resize.prototype.resizeHeightRGB">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeHeightRGB
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resizeHeightRGB = function (buffer) {
    var ratioWeight = this.ratioWeightHeightPass;
    var ratioWeightDivisor = 1 / ratioWeight;
    var weight = 0;
    var amountToNext = 0;
    var actualPosition = 0;
    var currentPosition = 0;
    var pixelOffset = 0;
    var outputOffset = 0;
    var output = this.outputHeightWorkBench;
    var outputBuffer = this.heightBuffer;
    do {
        for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            if (weight &#x3e;= amountToNext) {
                for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
                }
                currentPosition = actualPosition;
                weight -= amountToNext;
            } else {
                for (pixelOffset = 0, amountToNext = actualPosition; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
                    output[pixelOffset++] += buffer[amountToNext++] * weight;
                    output[pixelOffset++] += buffer[amountToNext++] * weight;
                    output[pixelOffset++] += buffer[amountToNext++] * weight;
                }
                currentPosition += weight;
                break;
            }
        } while (weight &#x3e; 0 &#x26;&#x26; actualPosition &#x3c; this.widthPassResultSize);
        for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
        }
    } while (outputOffset &#x3c; this.finalResultSize);
    return outputBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resizeHeightRGBA" id="apidoc.element.jimp.resize.prototype.resizeHeightRGBA">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeHeightRGBA
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resizeHeightRGBA = function (buffer) {
    var ratioWeight = this.ratioWeightHeightPass;
    var ratioWeightDivisor = 1 / ratioWeight;
    var weight = 0;
    var amountToNext = 0;
    var actualPosition = 0;
    var currentPosition = 0;
    var pixelOffset = 0;
    var outputOffset = 0;
    var output = this.outputHeightWorkBench;
    var outputBuffer = this.heightBuffer;
    do {
        for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            if (weight &#x3e;= amountToNext) {
                for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
                }
                currentPosition = actualPosition;
                weight -= amountToNext;
            } else {
                for (pixelOffset = 0, amountToNext = actualPosition; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
                    output[pixelOffset++] += buffer[amountToNext++] * weight;
                    output[pixelOffset++] += buffer[amountToNext++] * weight;
                    output[pixelOffset++] += buffer[amountToNext++] * weight;
                    output[pixelOffset++] += buffer[amountToNext++] * weight;
                }
                currentPosition += weight;
                break;
            }
        } while (weight &#x3e; 0 &#x26;&#x26; actualPosition &#x3c; this.widthPassResultSize);
        for (pixelOffset = 0; pixelOffset &#x3c; this.targetWidthMultipliedByChannels;) {
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
        }
    } while (outputOffset &#x3c; this.finalResultSize);
    return outputBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resizeWidthInterpolatedRGB" id="apidoc.element.jimp.resize.prototype.resizeWidthInterpolatedRGB">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthInterpolatedRGB
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resizeWidthInterpolatedRGB = function (buffer) {
    var ratioWeight = this.ratioWeightWidthPass;
    var weight = 0;
    var finalOffset = 0;
    var pixelOffset = 0;
    var firstWeight = 0;
    var secondWeight = 0;
    var outputBuffer = this.widthBuffer;
    //Handle for only one interpolation input being valid for start calculation:
    for (var targetPosition = 0; weight &#x3c; 1 / 3; targetPosition += 3, weight += ratioWeight) {
        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset &#x3c; this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels
, finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
        }
    }
    //Adjust for overshoot of the last pass&#x27;s counter:
    weight -= 1 / 3;
    for (var interpolationWidthSourceReadStop = this.widthOriginal - 1; weight &#x3c; interpolationWidthSourceReadStop; targetPosition
 += 3, weight += ratioWeight) {
        //Calculate weightings:
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        //Interpolate:
        for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * 3; finalOffset &#x3c; this.widthPassResultSize; pixelOffset
 += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = (buffer[pixelOffset] * firstWeight) + (buffer[pixelOffset + 3] * secondWeight);
            outputBuffer[finalOffset + 1] = (buffer[pixelOffset + 1] * firstWeight) + (buffer[pixelOffset + 4] * secondWeight);
            outputBuffer[finalOffset + 2] = (buffer[pixelOffset + 2] * firstWeight) + (buffer[pixelOffset + 5] * secondWeight);
        }
    }
    //Handle for only one interpolation input being valid for end calculation:
    for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - 3; targetPosition &#x3c; this.targetWidthMultipliedByChannels
; targetPosition += 3) {
        for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset &#x3c; this.widthPassResultSize
; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
        }
    }
    return outputBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resizeWidthInterpolatedRGBA" id="apidoc.element.jimp.resize.prototype.resizeWidthInterpolatedRGBA">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthInterpolatedRGBA
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resizeWidthInterpolatedRGBA = function (buffer) {
    var ratioWeight = this.ratioWeightWidthPass;
    var weight = 0;
    var finalOffset = 0;
    var pixelOffset = 0;
    var firstWeight = 0;
    var secondWeight = 0;
    var outputBuffer = this.widthBuffer;
    //Handle for only one interpolation input being valid for start calculation:
    for (var targetPosition = 0; weight &#x3c; 1 / 3; targetPosition += 4, weight += ratioWeight) {
        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset &#x3c; this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels
, finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
    }
    //Adjust for overshoot of the last pass&#x27;s counter:
    weight -= 1 / 3;
    for (var interpolationWidthSourceReadStop = this.widthOriginal - 1; weight &#x3c; interpolationWidthSourceReadStop; targetPosition
 += 4, weight += ratioWeight) {
        //Calculate weightings:
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        //Interpolate:
        for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * 4; finalOffset &#x3c; this.widthPassResultSize; pixelOffset
 += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = (buffer[pixelOffset] * firstWeight) + (buffer[pixelOffset + 4] * secondWeight);
            outputBuffer[finalOffset + 1] = (buffer[pixelOffset + 1] * firstWeight) + (buffer[pixelOffset + 5] * secondWeight);
            outputBuffer[finalOffset + 2] = (buffer[pixelOffset + 2] * firstWeight) + (buffer[pixelOffset + 6] * secondWeight);
            outputBuffer[finalOffset + 3] = (buffer[pixelOffset + 3] * firstWeight) + (buffer[pixelOffset + 7] * secondWeight);
        }
    }
    //Handle for only one interpolation input being valid for end calculation:
    for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - 4; targetPosition &#x3c; this.targetWidthMultipliedByChannels
; targetPosition += 4) {
        for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset &#x3c; this.widthPassResultSize
; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
    }
    return outputBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resizeWidthRGB" id="apidoc.element.jimp.resize.prototype.resizeWidthRGB">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthRGB
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resizeWidthRGB = function (buffer) {
    var ratioWeight = this.ratioWeightWidthPass;
    var ratioWeightDivisor = 1 / ratioWeight;
    var weight = 0;
    var amountToNext = 0;
    var actualPosition = 0;
    var currentPosition = 0;
    var line = 0;
    var pixelOffset = 0;
    var outputOffset = 0;
    var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - 2;
    var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - 2;
    var output = this.outputWidthWorkBench;
    var outputBuffer = this.widthBuffer;
    do {
        for (line = 0; line &#x3c; this.originalHeightMultipliedByChannels;) {
            output[line++] = 0;
            output[line++] = 0;
            output[line++] = 0;
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            if (weight &#x3e;= amountToNext) {
                for (line = 0, pixelOffset = actualPosition; line &#x3c; this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth
) {
                    output[line++] += buffer[pixelOffset++] * amountToNext;
                    output[line++] += buffer[pixelOffset++] * amountToNext;
                    output[line++] += buffer[pixelOffset] * amountToNext;
                }
                currentPosition = actualPosition = actualPosition + 3;
                weight -= amountToNext;
            } else {
                for (line = 0, pixelOffset = actualPosition; line &#x3c; this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth
) {
                    output[line++] += buffer[pixelOffset++] * weight;
                    output[line++] += buffer[pixelOffset++] * weight;
                    output[line++] += buffer[pixelOffset] * weight;
                }
                currentPosition += weight;
                break;
            }
        } while (weight &#x3e; 0 &#x26;&#x26; actualPosition &#x3c; this.originalWidthMultipliedByChannels);
        for (line = 0, pixelOffset = outputOffset; line &#x3c; this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth
) {
            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
            outputBuffer[pixelOffset] = output[line++] * ratioWeightDivisor;
        }
        outputOffset += 3;
    } while (outputOffset &#x3c; this.targetWidthMultipliedByChannels);
    return outputBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize.prototype.resizeWidthRGBA" id="apidoc.element.jimp.resize.prototype.resizeWidthRGBA">
        function <span class="apidocSignatureSpan">jimp.resize.prototype.</span>resizeWidthRGBA
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resizeWidthRGBA = function (buffer) {
    var ratioWeight = this.ratioWeightWidthPass;
    var ratioWeightDivisor = 1 / ratioWeight;
    var weight = 0;
    var amountToNext = 0;
    var actualPosition = 0;
    var currentPosition = 0;
    var line = 0;
    var pixelOffset = 0;
    var outputOffset = 0;
    var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - 3;
    var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - 3;
    var output = this.outputWidthWorkBench;
    var outputBuffer = this.widthBuffer;
    do {
        for (line = 0; line &#x3c; this.originalHeightMultipliedByChannels;) {
            output[line++] = 0;
            output[line++] = 0;
            output[line++] = 0;
            output[line++] = 0;
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            if (weight &#x3e;= amountToNext) {
                for (line = 0, pixelOffset = actualPosition; line &#x3c; this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth
) {
                    output[line++] += buffer[pixelOffset++] * amountToNext;
                    output[line++] += buffer[pixelOffset++] * amountToNext;
                    output[line++] += buffer[pixelOffset++] * amountToNext;
                    output[line++] += buffer[pixelOffset] * amountToNext;
                }
                currentPosition = actualPosition = actualPosition + 4;
                weight -= amountToNext;
            } else {
                for (line = 0, pixelOffset = actualPosition; line &#x3c; this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth
) {
                    output[line++] += buffer[pixelOffset++] * weight;
                    output[line++] += buffer[pixelOffset++] * weight;
                    output[line++] += buffer[pixelOffset++] * weight;
                    output[line++] += buffer[pixelOffset] * weight;
                }
                currentPosition += weight;
                break;
            }
        } while (weight &#x3e; 0 &#x26;&#x26; actualPosition &#x3c; this.originalWidthMultipliedByChannels);
        for (line = 0, pixelOffset = outputOffset; line &#x3c; this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth
) {
            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
            outputBuffer[pixelOffset] = output[line++] * ratioWeightDivisor;
        }
        outputOffset += 4;
    } while (outputOffset &#x3c; this.targetWidthMultipliedByChannels);
    return outputBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jimp.resize2" id="apidoc.module.jimp.resize2">module jimp.resize2</a></h1>


    <h2>
        <a href="#apidoc.element.jimp.resize2._interpolate2D" id="apidoc.element.jimp.resize2._interpolate2D">
        function <span class="apidocSignatureSpan">jimp.resize2.</span>_interpolate2D
        <span class="apidocSignatureSpan">(src, dst, options, interpolate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_interpolate2D = function (src, dst, options, interpolate) {

    var bufSrc = src.data;
    var bufDst = dst.data;

    var wSrc = src.width;
    var hSrc = src.height;
    //console.log(&#x22;wSrc=&#x22;+wSrc + &#x22;, hSrc=&#x22;+hSrc + &#x22;, srcLen=&#x22;+bufSrc.length);

    var wDst = dst.width;
    var hDst = dst.height;
    //console.log(&#x22;wDst=&#x22;+wDst + &#x22;, hDst=&#x22;+hDst + &#x22;, dstLen=&#x22;+bufDst.length);

    // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares
    var wM = Math.max(1, Math.floor(wSrc / wDst));
    var wDst2 = wDst * wM;
    var hM = Math.max(1, Math.floor(hSrc / hDst));
    var hDst2 = hDst * hM;
    //console.log(&#x22;wM=&#x22;+wM + &#x22;, wDst2=&#x22;+wDst2 + &#x22;, hM=&#x22;+hM + &#x22;, hDst2=&#x22;+hDst2);

    // ===========================================================
    // Pass 1 - interpolate rows
    // buf1 has width of dst2 and height of src
    var buf1 = new Buffer(wDst2 * hSrc * 4);
    for (var i = 0; i &#x3c; hSrc; i++) {
        for (var j = 0; j &#x3c; wDst2; j++) {
            // i in src coords, j in dst coords

            // calculate x in src coords
            // this interpolation requires 4 sample points and the two inner ones must be real
            // the outer points can be fudged for the edges.
            // therefore (wSrc-1)/wDst2
            var x = j * (wSrc-1) / wDst2;
            var xPos = Math.floor(x);
            var t = x - xPos;
            var srcPos = (i * wSrc + xPos) * 4;

            var buf1Pos = (i * wDst2 + j) * 4;
            for (var k = 0; k &#x3c; 4; k++) {
                var kPos = srcPos + k;
                var x0 = (xPos &#x3e; 0) ? bufSrc[kPos - 4] : 2*bufSrc[kPos]-bufSrc[kPos+4];
                var x1 = bufSrc[kPos];
                var x2 = bufSrc[kPos + 4];
                var x3 = (xPos &#x3c; wSrc - 2) ? bufSrc[kPos + 8] : 2*bufSrc[kPos + 4]-bufSrc[kPos];
                buf1[buf1Pos+k] = interpolate(x0,x1,x2,x3,t);
            }
        }
    }
    //this._writeFile(wDst2, hSrc, buf1, &#x22;out/buf1.jpg&#x22;);

    // ===========================================================
    // Pass 2 - interpolate columns
    // buf2 has width and height of dst2
    var buf2 = new Buffer(wDst2 * hDst2 * 4);
    for (var i = 0; i &#x3c; hDst2; i++) {
        for (var j = 0; j &#x3c; wDst2; j++) {
            // i&#x26;j in dst2 coords

            // calculate y in buf1 coords
            // this interpolation requires 4 sample points and the two inner ones must be real
            // the outer points can be fudged for the edges.
            // therefore (hSrc-1)/hDst2
            var y = i * (hSrc-1) / hDst2;
            var yPos = Math.floor(y);
            var t = y - yPos;
            var buf1Pos = (yPos * wDst2 + j) * 4;
            var buf2Pos = (i * wDst2 + j) * 4;
            for (var k = 0; k &#x3c; 4; k++) {
                var kPos = buf1Pos + k;
                var y0 = (yPos &#x3e; 0) ? buf1[kPos - wDst2*4] : 2*buf1[kPos]-buf1[kPos + wDst2*4];
                var y1 = buf1[kPos];
                var y2 = buf1[kPos + wDst2*4];
                var y3 = (yPos &#x3c; hSrc-2) ? buf1[kPos + wDst2*8] : 2*buf1[kPos + wDst2*4]-buf1[kPos];

                buf2[buf2Pos + k] = interpolate(y0,y1,y2,y3,t);
            }
        }
    }
    //this._writeFile(wDst2, hDst2, buf2, &#x22;out/buf2.jpg&#x22;);

    // ===========================================================
    // Pass 3 - scale to dst
    var m = wM * hM;
    if (m &#x3e; 1) {
        for (var i = 0; i &#x3c; hDst; i++) {
            for (var j = 0; j &#x3c; wDst; j++) {
                // i&#x26;j in dst bounded coords
                var r = 0;
                var g = 0;
                var b = 0;
                var a = 0;
                for (var y = 0; y &#x3c; hM; y++) {
                    var yPos = i * hM + y;
                    for (var x = 0; x &#x3c; wM; x++) {
                        var xPos = j * wM + x;
                        var xyPos = (yPos * wDst2 + xPos) * 4;
                        r += buf2[xyPos];
                        g += buf2[xyPos+1];
                        b += buf2[xyPos+2]; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var interpolateCubic = function(x0, x1, x2, x3, t) {
        var a0 = x3 - x2 - x0 + x1;
        var a1 = x0 - x1 - a0;
        var a2 = x2 - x0;
        var a3 = x1;
        return Math.max(0,Math.min(255,(a0 * (t * t * t)) + (a1 * (t * t)) + (a2 * t) + (a3)));
    }
    return this.<span class="apidocCodeKeywordSpan">_interpolate2D</span>(src, dst, options, interpolateCubic);
},

hermiteInterpolation: function(src, dst, options) {
    var interpolateHermite = function(x0, x1, x2, x3, t)
    {
        var c0 = x1;
        var c1 = 0.5 * (x2 - x0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize2.bezierInterpolation" id="apidoc.element.jimp.resize2.bezierInterpolation">
        function <span class="apidocSignatureSpan">jimp.resize2.</span>bezierInterpolation
        <span class="apidocSignatureSpan">(src, dst, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bezierInterpolation = function (src, dst, options) {
    // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)
    // to predict control points (a &#x26; b) to be placed at n+0.5
    //  ya(n) = y(n) + (y(n+1)-y(n-1))/4
    //  yb(n) = y(n+1) - (y(n+2)-y(n))/4
    // then use std bezier to interpolate [n,n+1)
    //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3
    //  note the 3* factor for the two control points
    // for edge cases, can choose:
    //  y(-1) = y(0) - 2*(y(1)-y(0))
    //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))
    // but can go with y(-1) = y(0) and y(w) = y(w-1)
    var interpolateBezier = function(x0, x1, x2, x3, t) {
        // x1, x2 are the knots, use x0 and x3 to calculate control points
        var cp1 = x1 + (x2-x0)/4;
        var cp2 = x2 - (x3-x1)/4;
        var nt = 1-t;
        var c0 =      x1 * nt * nt * nt;
        var c1 = 3 * cp1 * nt * nt *  t;
        var c2 = 3 * cp2 * nt *  t *  t;
        var c3 =      x2 *  t *  t *  t;
        return Math.max(0,Math.min(255,Math.round(c0 + c1 + c2 + c3)));
    }
    return this._interpolate2D(src, dst, options, interpolateBezier);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize2.bicubicInterpolation" id="apidoc.element.jimp.resize2.bicubicInterpolation">
        function <span class="apidocSignatureSpan">jimp.resize2.</span>bicubicInterpolation
        <span class="apidocSignatureSpan">(src, dst, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bicubicInterpolation = function (src, dst, options) {
    var interpolateCubic = function(x0, x1, x2, x3, t) {
        var a0 = x3 - x2 - x0 + x1;
        var a1 = x0 - x1 - a0;
        var a2 = x2 - x0;
        var a3 = x1;
        return Math.max(0,Math.min(255,(a0 * (t * t * t)) + (a1 * (t * t)) + (a2 * t) + (a3)));
    }
    return this._interpolate2D(src, dst, options, interpolateCubic);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize2.bilinearInterpolation" id="apidoc.element.jimp.resize2.bilinearInterpolation">
        function <span class="apidocSignatureSpan">jimp.resize2.</span>bilinearInterpolation
        <span class="apidocSignatureSpan">(src, dst, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bilinearInterpolation = function (src, dst, options) {

    var wSrc = src.width;
    var hSrc = src.height;
    //console.log(&#x22;wSrc=&#x22;+wSrc + &#x22;, hSrc=&#x22;+hSrc);

    var wDst = dst.width;
    var hDst = dst.height;
    //console.log(&#x22;wDst=&#x22;+wDst + &#x22;, hDst=&#x22;+hDst);

    var bufSrc = src.data;
    var bufDst = dst.data;

    var interpolate = function(k, kMin, vMin, kMax, vMax) {
        // special case - k is integer
        if (kMin === kMax) {
            return vMin;
        }

        return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
    };
    var assign = function(pos, offset, x, xMin, xMax, y, yMin, yMax) {
        var posMin = (yMin * wSrc + xMin) * 4 + offset;
        var posMax = (yMin * wSrc + xMax) * 4 + offset;
        var vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);

        // special case, y is integer
        if (yMax === yMin) {
            bufDst[pos+offset] = vMin;
        } else {
            posMin = (yMax * wSrc + xMin) * 4 + offset;
            posMax = (yMax * wSrc + xMax) * 4 + offset;
            var vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);

            bufDst[pos+offset] = interpolate(y, yMin, vMin, yMax, vMax);
        }
    }

    for (var i = 0; i &#x3c; hDst; i++) {
        for (var j = 0; j &#x3c; wDst; j++) {
            var posDst = (i * wDst + j) * 4;

            // x &#x26; y in src coordinates
            var x = j * wSrc / wDst;
            var xMin = Math.floor(x);
            var xMax = Math.min(Math.ceil(x), wSrc-1);

            var y = i * hSrc / hDst;
            var yMin = Math.floor(y);
            var yMax = Math.min(Math.ceil(y), hSrc-1);

            assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize2.hermiteInterpolation" id="apidoc.element.jimp.resize2.hermiteInterpolation">
        function <span class="apidocSignatureSpan">jimp.resize2.</span>hermiteInterpolation
        <span class="apidocSignatureSpan">(src, dst, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hermiteInterpolation = function (src, dst, options) {
    var interpolateHermite = function(x0, x1, x2, x3, t)
    {
        var c0 = x1;
        var c1 = 0.5 * (x2 - x0);
        var c2 = x0 - (2.5 * x1) + (2 * x2) - (0.5 * x3);
        var c3 = (0.5 * (x3 - x0)) + (1.5 * (x1 - x2));
        return  Math.max(0,Math.min(255,Math.round((((((c3 * t) + c2) * t) + c1) * t) + c0)));
    }
    return this._interpolate2D(src, dst, options, interpolateHermite);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jimp.resize2.nearestNeighbor" id="apidoc.element.jimp.resize2.nearestNeighbor">
        function <span class="apidocSignatureSpan">jimp.resize2.</span>nearestNeighbor
        <span class="apidocSignatureSpan">(src, dst, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nearestNeighbor = function (src, dst, options) {

    var wSrc = src.width;
    var hSrc = src.height;
    //console.log(&#x22;wSrc=&#x22;+wSrc + &#x22;, hSrc=&#x22;+hSrc);

    var wDst = dst.width;
    var hDst = dst.height;
    //console.log(&#x22;wDst=&#x22;+wDst + &#x22;, hDst=&#x22;+hDst);

    var bufSrc = src.data;
    var bufDst = dst.data;

    for (var i = 0; i &#x3c; hDst; i++) {
        for (var j = 0; j &#x3c; wDst; j++) {
            var posDst = (i * wDst + j) * 4;

            var iSrc = Math.round(i * hSrc / hDst);
            var jSrc = Math.round(j * wSrc / wDst);
            var posSrc = (iSrc * wSrc + jSrc) * 4;

            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
